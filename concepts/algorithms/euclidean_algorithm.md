# 유클리드 호제법 (Euclidean Algorithm)

## 📚 정의
- 두 개의 양의 정수 또는 다항식의 **최대공약수(GCD)**를 구하는 가장 효율적인 알고리즘입니다.

---

## 🔑 핵심 원리
- 두 양의 정수 `a`, `b` (`a > b`)에 대해, **`a`와 `b`의 최대공약수는 `b`와 `a`를 `b`로 나눈 나머지(`a % b`)의 최대공약수와 같다**는 원리를 이용합니다.
- 이 과정을 나머지(`a % b`)가 0이 될 때까지 반복하며, 나머지가 0이 되었을 때의 나누는 수 `b`가 바로 두 수의 최대공약수입니다.
- **시간 복잡도**: $O(\log(\min(a, b)))$. 입력값의 크기가 커져도 연산 횟수는 로그 스케일로 증가하기 때문에 매우 빠릅니다.
- **공간 복잡도**: 반복문으로 구현 시 $O(1)$, 재귀로 구현 시 $O(\log(\min(a, b)))$ (콜 스택 사용).

---

## 📝 주요 특징 및 용도
- **주요 용도**: 두 수의 최대공약수(GCD)를 빠르고 효율적으로 계산할 때 사용합니다.
- **장점**: 구현이 매우 간단하고, 큰 수에 대해서도 월등히 빠른 성능을 보장하여 코딩 테스트에서 시간 초과 걱정 없이 사용할 수 있습니다.
- **확장 용도**: 최소공배수(LCM)는 `LCM(a, b) = (a * b) / GCD(a, b)` 공식을 통해 유클리드 호제법으로 GCD를 구한 뒤 계산하는 것이 일반적입니다.

---

## 💻 구현 예시 (Python - 반복문)
- 재귀보다 스택 오버플로우의 위험이 없고, 미세하게 더 효율적인 반복문 기반의 구현입니다.

```python
def gcd(a, b):
    # a가 b보다 크다는 것을 보장 (선택사항이지만 명료함을 위함)
    if a < b:
        a, b = b, a

    # 유클리드 호제법의 핵심 원리
    # b가 0이 될 때까지 반복
    while b > 0:
        # a는 b로, b는 a를 b로 나눈 나머지로 바꾼다
        a, b = b, a % b

    # 반복문이 끝나면 a에 최대공약수가 남는다
    return a

# 예시
num1 = 192
num2 = 72
result = gcd(num1, num2)
print(f"{num1}과(와) {num2}의 최대공약수는 {result}입니다.")
# 출력: 192과(와) 72의 최대공약수는 24입니다.