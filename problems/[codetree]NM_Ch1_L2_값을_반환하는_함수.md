# 함수를 이용한 소수 판별

## 🔍 문제 정보
- **문제 출처:** 코드 트리 - Novice MID - 함수 - 값을 반환하는 함수
- **난이도:** Easy
- **관련 알고리즘:** #소수판별 #함수 #완전탐색

---

## 🤔 나의 풀이 (접근 방식)
- 문제의 요구사항은 "A와 B 사이의 모든 소수의 합"을 구하는 것이었다. 따라서, 가장 먼저 생각한 접근법은 다음과 같다.
    1. A부터 B까지의 모든 정수를 순회하는 반복문을 만든다.
    2. 반복문 안에서, 현재 숫자가 '소수'인지 아닌지를 판별한다.
    3. 만약 소수라면, 합계를 저장하는 변수에 더해준다.
- 이 과정에서 '소수 판별'이라는 기능이 반복적으로 사용되므로, 문제의 요구사항대로 `is_prime(n)`이라는 별도의 함수로 분리하여 관리하는 것이 효율적이라고 판단했다.
- 문제의 제한 조건이 `A, B <= 100`으로 매우 작았기 때문에, 시간 복잡도에 대한 큰 고민 없이 기본적인 소수 판별 로직으로도 충분히 해결 가능하다고 생각했다.

---

## 💡 해결 과정 (핵심 아이디어)
- 처음 작성한 `is_prime` 함수에서 논리적인 오류가 있었다. 나누어 떨어지는 수(소수가 아닌 경우)를 찾았을 때 `True`를 반환하고, 소수일 경우에 대한 반환 값이 명시되지 않아 코드가 의도대로 동작하지 않았다.
- **핵심 해결 아이디어:** 함수의 역할을 명확히 재정의했다. '소수 판별' 함수는 "단 하나의 약수라도 발견되는 즉시 `False`를 반환(`Early Return`)하고, 모든 검사를 통과했을 때만 마지막에 `True`를 반환해야 한다"는 원칙을 적용하여 버그를 수정했다.
- **추가 학습 내용 (튜터의 코드 리뷰):**
    1. **성능 최적화:** 소수 판별 시 `2`부터 `n-1`까지 모두 확인할 필요 없이, `n`의 제곱근까지만 확인하면 훨씬 효율적이라는 것을 배웠다. 이 아이디어를 적용하여 `is_prime` 함수를 개선했다.
    2. **가독성 개선:** `if is_prime(i) == True:` 와 같은 코드보다, `is_prime(i)`의 반환 값 자체가 Boolean이므로 `if is_prime(i):` 로 작성하는 것이 더 간결하고 파이썬스러운(Pythonic) 코드라는 것을 배웠다.

---

## 💻 코드
- **언어:** Python
- **설명:** 주어진 범위 `[a, b]` 내의 숫자들을 반복하면서, 최적화된 `is_prime` 함수를 통해 소수 여부를 판별하고 합계를 구합니다.

```python
# a와 b를 입력받습니다.
a, b = map(int, input().split())

# n이 소수인지 판별하는 함수 (제곱근까지 확인하여 최적화)
def is_prime(n):
    # 1 이하는 소수가 아님
    if n < 2:
        return False
    
    # 2부터 n의 제곱근까지만 반복
    for i in range(2, int(n**0.5) + 1):
        # 나누어 떨어지는 수가 있다면 소수가 아님
        if n % i == 0:
            return False
            
    # 반복문이 모두 끝났다면 소수임
    return True

# 소수의 합을 저장할 변수
total_sum = 0

# a부터 b까지의 모든 숫자를 확인
for i in range(a, b + 1):
    # is_prime 함수를 호출하여 소수인지 판별
    if is_prime(i):
        # 소수라면 합계에 더함
        total_sum += i

# 최종 합계 출력
print(total_sum)